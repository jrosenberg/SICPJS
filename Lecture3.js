//Example from SICP JS 1.3.2//f(x,y)=x(1+xy)2 +y(1−y)+(1+xy)(1−y)//Compute f (2, 3)function f(x, y) {const a = 1 + x * y;const b = 1 - y;return x * square(a) + y * b + a * b;}f(2, 3);//Applicative order reduction, 1.1.5function sq(x) { return x * x; }function sum_of_sqs(x,y) { return sq(x)+sq(y);} function f(a) { return sum_of_sqs(a+1, a*2);}f(5)//Substitution model for runesfunction turn_upside_down(rune) {     return quarter_turn_right(        quarter_turn_right(rune));}function quarter_turn_left(rune) {    return quarter_turn_right( turn_upside_down(rune));} quarter_turn_left(heart);//Another substitution example: Factorial 1.2.1function factorial(n) {    return n === 1    ? 1    : n * factorial(n - 1);}//Iterative factorialfunction factorial(n) {    return iter(1, 1, n);}function iter(product, counter, n) {    return counter > n    ? product    : iter(counter * product ,            counter + 1,             n);}//Example from "Rune Reading":// fractal_1// tree recursionfunction fractal_1(rune, n) {     return n === 1        ? rune        : beside(rune,            stack(fractal_1(rune, n - 1),                 fractal_1(rune, n - 1)));                //want to avoid repeat calls}// fractal_2 -- good idea? NO!// recursive call in const before returnfunction fractal_2(rune, n) {    const sub_frac = fractal_2(rune, n - 1);     return n === 1        ? rune        : beside(rune, stack(sub_frac, sub_frac))}// fractal_3// Each branch of the conditional is a block.// A block can have local names, only visible inside the block.// Remember to return a result in each branch.// (Otherwise undefined is returned.)// Remove from "tree recursion" to linear// # of recursive calls grows linearly// JS -- const is declaration of name, not immutablefunction fractal_3(rune, n) {     if (n === 1) {        return rune; }    else {        const f = fractal_3(rune, n - 1);        return beside(rune, stack(f, f)); }}// fractals with iterative processfunction iter(rune, n, current_fractal) {     return n === 1        ? current_fractal        : iter(rune, n - 1,            beside(rune, stack(current_fractal,                                 current_fractal )));}function fractal_4(rune, n) {    return iter(rune, n, rune); }// "divine" solutionfunction fractal_5(rune, n) {     return n === 1        ? rune        : beside(rune,            fractal_5(stack(rune, rune),                 n - 1));}// Rick the Rabbitfunction t(n) {    return n < 0    ? 0    : n === 0    ? 1    : rabbit_ways(n - 1) // Rick hops        +        rabbit_ways(n - 2) // Rick skips         +        rabbit_ways(n - 3); // Rick jumps}// Coin change// 5 step solutions:// 1 read the problem VERY CAREFULLY & clarify// 2 play with examples// 3 think: existing solution? divide&conquer? wishful thinking?// 4 program using Source// 5 test your programfunction first_denomination(kinds_of_coins) {returnkinds_of_coins === 1 ? kinds_of_coins === 2 ? kinds_of_coins === 3 ? kinds_of_coins === 4 ? kinds_of_coins === 5 ?5: 10 : 20 : 50 :100 : 0;function cc(amount , kinds_of_coins) { return ...}? /* base cases */ : cc(amount -first_denomination(kinds_of_coins),kinds_of_coins) +cc(amount , kinds_of_coins - 1);function cc(amount , kinds_of_coins) {}returnamount === 0?1: amount < 0 || kinds_of_coins === 0 ?0: cc(amount -first_denomination(kinds_of_coins),kinds_of_coins) +cc(amount ,kinds_of_coins- 1);// Higher order functions// passing functions to functionsfunction f(g, x) {     return g(g(x));}function g(y) {     return y + 1;}f(g, 7);// Example 1.3.1function sum_integers(a, b) {     return a > b    ? 0    : a + sum_integers(a + 1, b);}// another example