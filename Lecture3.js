//Example from SICP JS 1.3.2//f(x,y)=x(1+xy)2 +y(1−y)+(1+xy)(1−y)//Compute f (2, 3)function f(x, y) {const a = 1 + x * y;const b = 1 - y;return x * square(a) + y * b + a * b;}f(2, 3);//Applicative order reduction, 1.1.5function sq(x) { return x * x; }function sum_of_sqs(x,y) { return sq(x)+sq(y);} function f(a) { return sum_of_sqs(a+1, a*2);}f(5)//Substitution model for runesfunction turn_upside_down(rune) {     return quarter_turn_right(        quarter_turn_right(rune));}function quarter_turn_left(rune) {    return quarter_turn_right( turn_upside_down(rune));} quarter_turn_left(heart);//Another substitution example: Factorial 1.2.1function factorial(n) {    return n === 1    ? 1    : n * factorial(n - 1);}//Iterative factorialfunction factorial(n) {    return iter(1, 1, n);}function iter(product, counter, n) {    return counter > n    ? product    : iter(counter * product ,            counter + 1,             n);}//Example from "Rune Reading": fractal_1// tree recursionfunction fractal_1(rune, n) {     return n === 1        ? rune        : beside(rune,            stack(fractal_1(rune, n - 1),                 fractal_1(rune, n - 1)));                //want to avoid repeat calls}// fractal_2 -- good idea? NO!// recursive call in const before returnfunction fractal_2(rune, n) {    const sub_frac = fractal_2(rune, n - 1);     return n === 1        ? rune        : beside(rune, stack(sub_frac, sub_frac))}// fractal_3function fractal_3(rune, n) {     if (n === 1) {        return rune; }    else {        const f = fractal_3(rune, n - 1);        return beside(rune, stack(f, f)); }}